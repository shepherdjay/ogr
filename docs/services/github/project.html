<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ogr.services.github.project API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ogr.services.github.project</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># MIT License
#
# Copyright (c) 2018-2019 Red Hat, Inc.

# Permission is hereby granted, free of charge, to any person obtaining a copy
# of this software and associated documentation files (the &#34;Software&#34;), to deal
# in the Software without restriction, including without limitation the rights
# to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# copies of the Software, and to permit persons to whom the Software is
# furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in all
# copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED &#34;AS IS&#34;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# SOFTWARE.

import datetime
import logging
from ogr.services.github.check_run import (
    GithubCheckRun,
    GithubCheckRunOutput,
    GithubCheckRunResult,
    GithubCheckRunStatus,
)
from typing import Optional, Dict, List, Set, Union

import github
from github import UnknownObjectException
from github.GithubException import GithubException
from github.Repository import Repository
from github.CommitComment import CommitComment as GithubCommitComment
from github.GitRelease import GitRelease as PyGithubRelease

from ogr.abstract import (
    Issue,
    IssueStatus,
    PullRequest,
    PRStatus,
    Release,
    CommitComment,
    GitTag,
    CommitFlag,
    CommitStatus,
    AccessLevel,
)
from ogr.exceptions import GithubAPIException, OperationNotSupported
from ogr.read_only import if_readonly, GitProjectReadOnly
from ogr.services import github as ogr_github
from ogr.services.base import BaseGitProject
from ogr.services.github.flag import GithubCommitFlag
from ogr.services.github.issue import GithubIssue
from ogr.services.github.pull_request import GithubPullRequest
from ogr.services.github.release import GithubRelease
from ogr.utils import filter_paths, indirect

logger = logging.getLogger(__name__)


class GithubProject(BaseGitProject):
    service: &#34;ogr_github.GithubService&#34;
    # Permission levels that can merge PRs
    CAN_MERGE_PERMS = [&#34;admin&#34;, &#34;write&#34;]

    def __init__(
        self,
        repo: str,
        service: &#34;ogr_github.GithubService&#34;,
        namespace: str,
        github_repo: Repository = None,
        read_only: bool = False,
        **unprocess_kwargs,
    ) -&gt; None:
        if unprocess_kwargs:
            logger.warning(
                f&#34;GithubProject will not process these kwargs: {unprocess_kwargs}&#34;
            )
        super().__init__(repo, service, namespace)
        self._github_repo = github_repo
        self.read_only = read_only

        self._github_instance = None

    @property
    def github_instance(self):
        if not self._github_instance:
            self._github_instance = self.service.get_pygithub_instance(
                self.namespace, self.repo
            )

        return self._github_instance

    @property
    def github_repo(self):
        if not self._github_repo:
            self._github_repo = self.github_instance.get_repo(
                full_name_or_id=f&#34;{self.namespace}/{self.repo}&#34;
            )
        return self._github_repo

    def __str__(self) -&gt; str:
        return f&#39;GithubProject(namespace=&#34;{self.namespace}&#34;, repo=&#34;{self.repo}&#34;)&#39;

    def __eq__(self, o: object) -&gt; bool:
        if not isinstance(o, GithubProject):
            return False

        return (
            self.repo == o.repo
            and self.namespace == o.namespace
            and self.service == o.service
            and self.read_only == o.read_only
        )

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            Project description.
        &#34;&#34;&#34;
        return self.github_repo.description

    @description.setter
    def description(self, new_description: str) -&gt; None:
        &#34;&#34;&#34;
        Args:
            new_description: description to set for project.
        &#34;&#34;&#34;
        self.github_repo.edit(description=new_description)

    def _construct_fork_project(self) -&gt; Optional[&#34;GithubProject&#34;]:
        gh_user = self.github_instance.get_user()
        user_login = gh_user.login
        try:
            project = GithubProject(
                self.repo, self.service, namespace=user_login, read_only=self.read_only
            )
            if not project.github_repo:
                # The github_repo attribute is lazy.
                return None
            return project
        except github.GithubException as ex:
            logger.debug(f&#34;Project {user_login}/{self.repo} does not exist: {ex}&#34;)
            return None

    def exists(self) -&gt; bool:
        try:
            _ = self.github_repo
            return True
        except UnknownObjectException as ex:
            if &#34;Not Found&#34; in str(ex):
                return False
            raise GithubAPIException from ex

    def is_private(self) -&gt; bool:
        &#34;&#34;&#34;
        Is this repo private? (accessible only by users with granted access)

        :return: if yes, return True
        &#34;&#34;&#34;
        return self.github_repo.private

    def is_forked(self) -&gt; bool:
        &#34;&#34;&#34;
        Is this repo forked by the authenticated user?

        :return: if yes, return True
        &#34;&#34;&#34;
        return bool(self._construct_fork_project())

    @property
    def is_fork(self) -&gt; bool:
        &#34;&#34;&#34;
        Is this repository a fork?

        :return: True if it is
        &#34;&#34;&#34;
        return self.github_repo.fork

    @property
    def parent(self) -&gt; Optional[&#34;GithubProject&#34;]:
        &#34;&#34;&#34;
        Return parent project if this project is a fork, otherwise return None
        &#34;&#34;&#34;
        return (
            self.service.get_project_from_github_repository(self.github_repo.parent)
            if self.is_fork
            else None
        )

    @property
    def default_branch(self):
        return self.github_repo.default_branch

    def get_branches(self) -&gt; List[str]:
        return [branch.name for branch in self.github_repo.get_branches()]

    def get_description(self) -&gt; str:
        return self.github_repo.description

    def add_user(self, user: str, access_level: AccessLevel) -&gt; None:
        &#34;&#34;&#34;
        AccessLevel.pull =&gt; Pull
        AccessLevel.triage =&gt; Triage
        AccessLevel.push =&gt; Push
        AccessLevel.admin =&gt; Admin
        AccessLevel.maintain =&gt; Maintain
        &#34;&#34;&#34;
        access_dict = {
            AccessLevel.pull: &#34;Pull&#34;,
            AccessLevel.triage: &#34;Triage&#34;,
            AccessLevel.push: &#34;Push&#34;,
            AccessLevel.admin: &#34;Admin&#34;,
            AccessLevel.maintain: &#34;Maintain&#34;,
        }
        try:
            invitation = self.github_repo.add_to_collaborators(
                user, permission=access_dict[access_level]
            )
        except Exception:
            raise GithubAPIException(&#34;User {user} not found&#34;)

        if invitation is None:
            raise GithubAPIException(&#34;User already added&#34;)

    def request_access(self):
        raise OperationNotSupported(&#34;Not possible on GitHub&#34;)

    def get_fork(self, create: bool = True) -&gt; Optional[&#34;GithubProject&#34;]:
        &#34;&#34;&#34;
        Provide GithubProject instance of a fork of this project.

        Returns None if this is a fork.

        :param create: create a fork if it doesn&#39;t exist
        :return: instance of GithubProject
        &#34;&#34;&#34;
        username = self.service.user.get_username()
        for fork in self.get_forks():
            if fork.github_repo.owner.login == username:
                return fork

        if not self.is_forked():
            if create:
                return self.fork_create()
            else:
                logger.info(
                    f&#34;Fork of {self.github_repo.full_name}&#34;
                    &#34; does not exist and we were asked not to create it.&#34;
                )
                return None
        return self._construct_fork_project()

    def get_owners(self) -&gt; List[str]:
        # in case of github, repository has only one owner
        return [self.github_repo.owner.login]

    def __get_collaborators(self) -&gt; Set[str]:
        try:
            collaborators = self._get_collaborators_with_permission()
        except github.GithubException:
            logger.debug(
                &#34;Current Github token must have push access to view repository permissions.&#34;
            )
            return set()

        usernames = []
        for login, permission in collaborators.items():
            if permission in self.CAN_MERGE_PERMS:
                usernames.append(login)

        return set(usernames)

    def who_can_close_issue(self) -&gt; Set[str]:
        return self.__get_collaborators()

    def who_can_merge_pr(self) -&gt; Set[str]:
        return self.__get_collaborators()

    def can_merge_pr(self, username) -&gt; bool:
        return (
            self.github_repo.get_collaborator_permission(username)
            in self.CAN_MERGE_PERMS
        )

    def _get_collaborators_with_permission(self) -&gt; dict:
        &#34;&#34;&#34;
        Get all project collaborators in dictionary with permission association
        :return: List of usernames
        &#34;&#34;&#34;
        collaborators = {}
        users = self.github_repo.get_collaborators()
        for user in users:
            permission = self.github_repo.get_collaborator_permission(user)
            collaborators[user.login] = permission
        return collaborators

    @indirect(GithubIssue.get_list)
    def get_issue_list(
        self,
        status: IssueStatus = IssueStatus.open,
        author: Optional[str] = None,
        assignee: Optional[str] = None,
        labels: Optional[List[str]] = None,
    ) -&gt; List[Issue]:
        pass

    @indirect(GithubIssue.get)
    def get_issue(self, issue_id: int) -&gt; Issue:
        pass

    @indirect(GithubIssue.create)
    def create_issue(
        self,
        title: str,
        body: str,
        private: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        assignees: Optional[List[str]] = None,
    ) -&gt; Issue:
        pass

    def delete(self) -&gt; None:
        self.github_repo.delete()

    @indirect(GithubPullRequest.get_list)
    def get_pr_list(self, status: PRStatus = PRStatus.open) -&gt; List[PullRequest]:
        pass

    @indirect(GithubPullRequest.get)
    def get_pr(self, pr_id: int) -&gt; PullRequest:
        pass

    def get_sha_from_tag(self, tag_name: str) -&gt; str:
        # TODO: This is ugly. Can we do it better?
        all_tags = self.github_repo.get_tags()
        for tag in all_tags:
            if tag.name == tag_name:
                return tag.commit.sha
        raise GithubAPIException(f&#34;Tag {tag_name} was not found.&#34;)

    def get_tag_from_tag_name(self, tag_name: str) -&gt; Optional[GitTag]:
        all_tags = self.github_repo.get_tags()
        for tag in all_tags:
            if tag.name == tag_name:
                return GitTag(name=tag.name, commit_sha=tag.commit.sha)
        return None

    @if_readonly(return_function=GitProjectReadOnly.create_pr)
    @indirect(GithubPullRequest.create)
    def create_pr(
        self,
        title: str,
        body: str,
        target_branch: str,
        source_branch: str,
        fork_username: str = None,
    ) -&gt; PullRequest:
        pass

    @if_readonly(
        return_function=GitProjectReadOnly.commit_comment,
        log_message=&#34;Create Comment to commit&#34;,
    )
    def commit_comment(
        self, commit: str, body: str, filename: str = None, row: int = None
    ) -&gt; CommitComment:
        &#34;&#34;&#34;
        Create comment on a commit.

        :param commit: str The SHA of the commit needing a comment.
        :param body: str The text of the comment
        :param filename: str The relative path to the file that necessitates a comment
        :param row: int Line index in the diff to comment on.
        :return: CommitComment
        &#34;&#34;&#34;
        github_commit = self.github_repo.get_commit(commit)
        if filename and row:
            comment = github_commit.create_comment(
                body=body, position=row, path=filename
            )
        else:
            comment = github_commit.create_comment(body=body)
        return self._commitcomment_from_github_object(comment)

    @if_readonly(
        return_function=GitProjectReadOnly.set_commit_status,
        log_message=&#34;Create a status on a commit&#34;,
    )
    @indirect(GithubCommitFlag.set)
    def set_commit_status(
        self,
        commit: str,
        state: Union[CommitStatus, str],
        target_url: str,
        description: str,
        context: str,
        trim: bool = False,
    ):
        &#34;&#34;&#34;
        Create a status on a commit

        :param commit: The SHA of the commit.
        :param state: The state of the status.
        :param target_url: The target URL to associate with this status.
        :param description: A short description of the status
        :param context: A label to differentiate this status from the status of other systems.
        :param trim: bool Whether to trim the description in order to avoid throwing
            github.GithubException
        :return:
        &#34;&#34;&#34;
        pass

    @indirect(GithubCommitFlag.get)
    def get_commit_statuses(self, commit: str) -&gt; List[CommitFlag]:
        &#34;&#34;&#34;
        Get status of the commit.

        :param commit: str
        :return: [CommitFlag]
        &#34;&#34;&#34;
        pass

    @indirect(GithubCheckRun.get)
    def get_check_run(
        self,
        check_run_id: Optional[int] = None,
        commit_sha: Optional[str] = None,
    ) -&gt; Optional[&#34;GithubCheckRun&#34;]:
        pass

    @indirect(GithubCheckRun.create)
    def create_check_run(
        self,
        name: str,
        commit_sha: str,
        url: Optional[str] = None,
        external_id: Optional[str] = None,
        status: GithubCheckRunStatus = GithubCheckRunStatus.queued,
        started_at: Optional[datetime.datetime] = None,
        conclusion: Optional[GithubCheckRunResult] = None,
        completed_at: Optional[datetime.datetime] = None,
        output: Optional[GithubCheckRunOutput] = None,
        actions: Optional[List[Dict[str, str]]] = None,
    ) -&gt; &#34;GithubCheckRun&#34;:
        pass

    @indirect(GithubCheckRun.get_list)
    def get_check_runs(
        self,
        commit_sha: str,
        name: Optional[str] = None,
        status: Optional[GithubCheckRunStatus] = None,
    ) -&gt; List[&#34;GithubCheckRun&#34;]:
        pass

    def get_git_urls(self) -&gt; Dict[str, str]:
        return {&#34;git&#34;: self.github_repo.clone_url, &#34;ssh&#34;: self.github_repo.ssh_url}

    @if_readonly(return_function=GitProjectReadOnly.fork_create)
    def fork_create(self) -&gt; &#34;GithubProject&#34;:
        &#34;&#34;&#34;
        Fork this project using the authenticated user.
        This may raise an exception if the fork already exists.

        :return: fork GithubProject instance
        &#34;&#34;&#34;
        gh_user = self.github_instance.get_user()
        fork = self.service.get_project_from_github_repository(
            gh_user.create_fork(self.github_repo)
        )
        logger.debug(f&#34;Forked to {fork.namespace}/{fork.repo}&#34;)
        return fork

    def change_token(self, new_token: str):
        raise OperationNotSupported

    def get_file_content(self, path: str, ref=None) -&gt; str:
        ref = ref or self.default_branch
        try:
            return self.github_repo.get_contents(
                path=path, ref=ref
            ).decoded_content.decode()
        except (UnknownObjectException, GithubException) as ex:
            if ex.status == 404:
                raise FileNotFoundError(f&#34;File &#39;{path}&#39; on {ref} not found&#34;, ex)
            raise GithubAPIException(ex)

    def get_files(
        self, ref: str = None, filter_regex: str = None, recursive: bool = False
    ) -&gt; List[str]:
        &#34;&#34;&#34;
        Get a list of file paths of the repo.
        :param ref: branch or commit (defaults to repo&#39;s default branch)
        :param filter_regex: filter the paths with re.search
        :param recursive: whether to return only top directory files or all files recursively
        :return: [str]
        &#34;&#34;&#34;
        ref = ref or self.default_branch
        paths = []
        contents = self.github_repo.get_contents(path=&#34;&#34;, ref=ref)

        if recursive:
            while contents:
                file_content = contents.pop(0)
                if file_content.type == &#34;dir&#34;:
                    contents.extend(
                        self.github_repo.get_contents(path=file_content.path, ref=ref)
                    )
                else:
                    paths.append(file_content.path)

        else:
            paths = [
                file_content.path
                for file_content in contents
                if file_content.type != &#34;dir&#34;
            ]

        if filter_regex:
            paths = filter_paths(paths, filter_regex)

        return paths

    def _release_from_github_object(
        self, raw_release: PyGithubRelease, git_tag: GitTag
    ) -&gt; GithubRelease:
        &#34;&#34;&#34;
        Get ogr.abstract.Release object from github.GithubRelease

        :param raw_release: GithubRelease, object from Github API
            https://developer.github.com/v3/repos/releases/
        :return: Release, example(type, value):
            tag_name: str, &#34;v1.0.0&#34;
            url: str, &#34;https://api.github.com/repos/octocat/Hello-World/releases/1&#34;
            created_at: datetime.datetime, 2018-09-19 12:56:26
            tarball_url: str, &#34;https://api.github.com/repos/octocat/Hello-World/tarball/v1.0.0&#34;
            git_tag: GitTag
            project: GithubProject
            raw_release: PyGithubRelease
        &#34;&#34;&#34;
        return GithubRelease(
            tag_name=raw_release.tag_name,
            url=raw_release.url,
            created_at=str(raw_release.created_at),
            tarball_url=raw_release.tarball_url,
            git_tag=git_tag,
            project=self,
            raw_release=raw_release,
        )

    @staticmethod
    def _commitcomment_from_github_object(
        raw_commitcoment: GithubCommitComment,
    ) -&gt; CommitComment:
        return CommitComment(
            comment=raw_commitcoment.body,
            author=raw_commitcoment.user.login,
            sha=raw_commitcoment.commit_id,
        )

    def get_labels(self):
        &#34;&#34;&#34;
        Get list of labels in the repository.
        :return: [Label]
        &#34;&#34;&#34;
        return list(self.github_repo.get_labels())

    def update_labels(self, labels):
        &#34;&#34;&#34;
        Update the labels of the repository. (No deletion, only add not existing ones.)

        :param labels: [str]
        :return: int - number of added labels
        &#34;&#34;&#34;
        current_label_names = [la.name for la in list(self.github_repo.get_labels())]
        changes = 0
        for label in labels:
            if label.name not in current_label_names:
                color = self._normalize_label_color(color=label.color)
                self.github_repo.create_label(
                    name=label.name, color=color, description=label.description or &#34;&#34;
                )

                changes += 1
        return changes

    @staticmethod
    def _normalize_label_color(color):
        if color.startswith(&#34;#&#34;):
            return color[1:]
        return color

    def _release_id_from_name(self, name) -&gt; Optional[int]:
        releases = self.github_repo.get_releases()
        for release in releases:
            if release.title == name:
                return release.id
        return None

    def _release_id_from_tag(self, tag) -&gt; Optional[int]:
        releases = self.github_repo.get_releases()
        for release in releases:
            if release.tag_name == tag:
                return release.id
        return None

    def get_release(self, identifier=None, name=None, tag_name=None) -&gt; GithubRelease:
        if tag_name:
            identifier = self._release_id_from_tag(tag_name)
        elif name:
            identifier = self._release_id_from_name(name)
        if identifier is None:
            raise GithubAPIException(&#34;Release was not found.&#34;)
        release = self.github_repo.get_release(id=identifier)
        return self._release_from_github_object(
            raw_release=release, git_tag=self.get_tag_from_tag_name(release.tag_name)
        )

    def get_latest_release(self) -&gt; Optional[GithubRelease]:
        try:
            release = self.github_repo.get_latest_release()
            return self._release_from_github_object(
                raw_release=release,
                git_tag=self.get_tag_from_tag_name(release.tag_name),
            )
        except GithubException as ex:
            if ex.status == 404:
                return None
            raise GithubAPIException from ex

    def get_releases(self) -&gt; List[Release]:
        releases = self.github_repo.get_releases()
        return [
            self._release_from_github_object(
                raw_release=release,
                git_tag=self.get_tag_from_tag_name(release.tag_name),
            )
            for release in releases
        ]

    def create_release(self, tag: str, name: str, message: str) -&gt; GithubRelease:
        created_release = self.github_repo.create_git_release(
            tag=tag, name=name, message=message
        )
        return self.get_release(created_release.id)

    def get_forks(self) -&gt; List[&#34;GithubProject&#34;]:
        &#34;&#34;&#34;
        Get forks of the project.

        :return: [PagureProject]
        &#34;&#34;&#34;
        return [
            self.service.get_project_from_github_repository(fork)
            for fork in self.github_repo.get_forks()
            if fork.owner
        ]

    def get_web_url(self) -&gt; str:
        &#34;&#34;&#34;
        Get web URL of the project.

        :return: str
        &#34;&#34;&#34;
        return self.github_repo.html_url

    def get_tags(self) -&gt; List[&#34;GitTag&#34;]:
        return [GitTag(tag.name, tag.commit.sha) for tag in self.github_repo.get_tags()]</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ogr.services.github.project.GithubProject"><code class="flex name class">
<span>class <span class="ident">GithubProject</span></span>
<span>(</span><span>repo: str, service: ogr_github.GithubService, namespace: str, github_repo: github.Repository.Repository = None, read_only: bool = False, **unprocess_kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:param repo: name of the project
:param service: GitService instance
:param namespace:
github: username or org name
gitlab: username or org name
pagure: namespace (e.g. "rpms")
for forks: "fork/{username}/{namespace}"</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GithubProject(BaseGitProject):
    service: &#34;ogr_github.GithubService&#34;
    # Permission levels that can merge PRs
    CAN_MERGE_PERMS = [&#34;admin&#34;, &#34;write&#34;]

    def __init__(
        self,
        repo: str,
        service: &#34;ogr_github.GithubService&#34;,
        namespace: str,
        github_repo: Repository = None,
        read_only: bool = False,
        **unprocess_kwargs,
    ) -&gt; None:
        if unprocess_kwargs:
            logger.warning(
                f&#34;GithubProject will not process these kwargs: {unprocess_kwargs}&#34;
            )
        super().__init__(repo, service, namespace)
        self._github_repo = github_repo
        self.read_only = read_only

        self._github_instance = None

    @property
    def github_instance(self):
        if not self._github_instance:
            self._github_instance = self.service.get_pygithub_instance(
                self.namespace, self.repo
            )

        return self._github_instance

    @property
    def github_repo(self):
        if not self._github_repo:
            self._github_repo = self.github_instance.get_repo(
                full_name_or_id=f&#34;{self.namespace}/{self.repo}&#34;
            )
        return self._github_repo

    def __str__(self) -&gt; str:
        return f&#39;GithubProject(namespace=&#34;{self.namespace}&#34;, repo=&#34;{self.repo}&#34;)&#39;

    def __eq__(self, o: object) -&gt; bool:
        if not isinstance(o, GithubProject):
            return False

        return (
            self.repo == o.repo
            and self.namespace == o.namespace
            and self.service == o.service
            and self.read_only == o.read_only
        )

    @property
    def description(self) -&gt; str:
        &#34;&#34;&#34;
        Returns:
            Project description.
        &#34;&#34;&#34;
        return self.github_repo.description

    @description.setter
    def description(self, new_description: str) -&gt; None:
        &#34;&#34;&#34;
        Args:
            new_description: description to set for project.
        &#34;&#34;&#34;
        self.github_repo.edit(description=new_description)

    def _construct_fork_project(self) -&gt; Optional[&#34;GithubProject&#34;]:
        gh_user = self.github_instance.get_user()
        user_login = gh_user.login
        try:
            project = GithubProject(
                self.repo, self.service, namespace=user_login, read_only=self.read_only
            )
            if not project.github_repo:
                # The github_repo attribute is lazy.
                return None
            return project
        except github.GithubException as ex:
            logger.debug(f&#34;Project {user_login}/{self.repo} does not exist: {ex}&#34;)
            return None

    def exists(self) -&gt; bool:
        try:
            _ = self.github_repo
            return True
        except UnknownObjectException as ex:
            if &#34;Not Found&#34; in str(ex):
                return False
            raise GithubAPIException from ex

    def is_private(self) -&gt; bool:
        &#34;&#34;&#34;
        Is this repo private? (accessible only by users with granted access)

        :return: if yes, return True
        &#34;&#34;&#34;
        return self.github_repo.private

    def is_forked(self) -&gt; bool:
        &#34;&#34;&#34;
        Is this repo forked by the authenticated user?

        :return: if yes, return True
        &#34;&#34;&#34;
        return bool(self._construct_fork_project())

    @property
    def is_fork(self) -&gt; bool:
        &#34;&#34;&#34;
        Is this repository a fork?

        :return: True if it is
        &#34;&#34;&#34;
        return self.github_repo.fork

    @property
    def parent(self) -&gt; Optional[&#34;GithubProject&#34;]:
        &#34;&#34;&#34;
        Return parent project if this project is a fork, otherwise return None
        &#34;&#34;&#34;
        return (
            self.service.get_project_from_github_repository(self.github_repo.parent)
            if self.is_fork
            else None
        )

    @property
    def default_branch(self):
        return self.github_repo.default_branch

    def get_branches(self) -&gt; List[str]:
        return [branch.name for branch in self.github_repo.get_branches()]

    def get_description(self) -&gt; str:
        return self.github_repo.description

    def add_user(self, user: str, access_level: AccessLevel) -&gt; None:
        &#34;&#34;&#34;
        AccessLevel.pull =&gt; Pull
        AccessLevel.triage =&gt; Triage
        AccessLevel.push =&gt; Push
        AccessLevel.admin =&gt; Admin
        AccessLevel.maintain =&gt; Maintain
        &#34;&#34;&#34;
        access_dict = {
            AccessLevel.pull: &#34;Pull&#34;,
            AccessLevel.triage: &#34;Triage&#34;,
            AccessLevel.push: &#34;Push&#34;,
            AccessLevel.admin: &#34;Admin&#34;,
            AccessLevel.maintain: &#34;Maintain&#34;,
        }
        try:
            invitation = self.github_repo.add_to_collaborators(
                user, permission=access_dict[access_level]
            )
        except Exception:
            raise GithubAPIException(&#34;User {user} not found&#34;)

        if invitation is None:
            raise GithubAPIException(&#34;User already added&#34;)

    def request_access(self):
        raise OperationNotSupported(&#34;Not possible on GitHub&#34;)

    def get_fork(self, create: bool = True) -&gt; Optional[&#34;GithubProject&#34;]:
        &#34;&#34;&#34;
        Provide GithubProject instance of a fork of this project.

        Returns None if this is a fork.

        :param create: create a fork if it doesn&#39;t exist
        :return: instance of GithubProject
        &#34;&#34;&#34;
        username = self.service.user.get_username()
        for fork in self.get_forks():
            if fork.github_repo.owner.login == username:
                return fork

        if not self.is_forked():
            if create:
                return self.fork_create()
            else:
                logger.info(
                    f&#34;Fork of {self.github_repo.full_name}&#34;
                    &#34; does not exist and we were asked not to create it.&#34;
                )
                return None
        return self._construct_fork_project()

    def get_owners(self) -&gt; List[str]:
        # in case of github, repository has only one owner
        return [self.github_repo.owner.login]

    def __get_collaborators(self) -&gt; Set[str]:
        try:
            collaborators = self._get_collaborators_with_permission()
        except github.GithubException:
            logger.debug(
                &#34;Current Github token must have push access to view repository permissions.&#34;
            )
            return set()

        usernames = []
        for login, permission in collaborators.items():
            if permission in self.CAN_MERGE_PERMS:
                usernames.append(login)

        return set(usernames)

    def who_can_close_issue(self) -&gt; Set[str]:
        return self.__get_collaborators()

    def who_can_merge_pr(self) -&gt; Set[str]:
        return self.__get_collaborators()

    def can_merge_pr(self, username) -&gt; bool:
        return (
            self.github_repo.get_collaborator_permission(username)
            in self.CAN_MERGE_PERMS
        )

    def _get_collaborators_with_permission(self) -&gt; dict:
        &#34;&#34;&#34;
        Get all project collaborators in dictionary with permission association
        :return: List of usernames
        &#34;&#34;&#34;
        collaborators = {}
        users = self.github_repo.get_collaborators()
        for user in users:
            permission = self.github_repo.get_collaborator_permission(user)
            collaborators[user.login] = permission
        return collaborators

    @indirect(GithubIssue.get_list)
    def get_issue_list(
        self,
        status: IssueStatus = IssueStatus.open,
        author: Optional[str] = None,
        assignee: Optional[str] = None,
        labels: Optional[List[str]] = None,
    ) -&gt; List[Issue]:
        pass

    @indirect(GithubIssue.get)
    def get_issue(self, issue_id: int) -&gt; Issue:
        pass

    @indirect(GithubIssue.create)
    def create_issue(
        self,
        title: str,
        body: str,
        private: Optional[bool] = None,
        labels: Optional[List[str]] = None,
        assignees: Optional[List[str]] = None,
    ) -&gt; Issue:
        pass

    def delete(self) -&gt; None:
        self.github_repo.delete()

    @indirect(GithubPullRequest.get_list)
    def get_pr_list(self, status: PRStatus = PRStatus.open) -&gt; List[PullRequest]:
        pass

    @indirect(GithubPullRequest.get)
    def get_pr(self, pr_id: int) -&gt; PullRequest:
        pass

    def get_sha_from_tag(self, tag_name: str) -&gt; str:
        # TODO: This is ugly. Can we do it better?
        all_tags = self.github_repo.get_tags()
        for tag in all_tags:
            if tag.name == tag_name:
                return tag.commit.sha
        raise GithubAPIException(f&#34;Tag {tag_name} was not found.&#34;)

    def get_tag_from_tag_name(self, tag_name: str) -&gt; Optional[GitTag]:
        all_tags = self.github_repo.get_tags()
        for tag in all_tags:
            if tag.name == tag_name:
                return GitTag(name=tag.name, commit_sha=tag.commit.sha)
        return None

    @if_readonly(return_function=GitProjectReadOnly.create_pr)
    @indirect(GithubPullRequest.create)
    def create_pr(
        self,
        title: str,
        body: str,
        target_branch: str,
        source_branch: str,
        fork_username: str = None,
    ) -&gt; PullRequest:
        pass

    @if_readonly(
        return_function=GitProjectReadOnly.commit_comment,
        log_message=&#34;Create Comment to commit&#34;,
    )
    def commit_comment(
        self, commit: str, body: str, filename: str = None, row: int = None
    ) -&gt; CommitComment:
        &#34;&#34;&#34;
        Create comment on a commit.

        :param commit: str The SHA of the commit needing a comment.
        :param body: str The text of the comment
        :param filename: str The relative path to the file that necessitates a comment
        :param row: int Line index in the diff to comment on.
        :return: CommitComment
        &#34;&#34;&#34;
        github_commit = self.github_repo.get_commit(commit)
        if filename and row:
            comment = github_commit.create_comment(
                body=body, position=row, path=filename
            )
        else:
            comment = github_commit.create_comment(body=body)
        return self._commitcomment_from_github_object(comment)

    @if_readonly(
        return_function=GitProjectReadOnly.set_commit_status,
        log_message=&#34;Create a status on a commit&#34;,
    )
    @indirect(GithubCommitFlag.set)
    def set_commit_status(
        self,
        commit: str,
        state: Union[CommitStatus, str],
        target_url: str,
        description: str,
        context: str,
        trim: bool = False,
    ):
        &#34;&#34;&#34;
        Create a status on a commit

        :param commit: The SHA of the commit.
        :param state: The state of the status.
        :param target_url: The target URL to associate with this status.
        :param description: A short description of the status
        :param context: A label to differentiate this status from the status of other systems.
        :param trim: bool Whether to trim the description in order to avoid throwing
            github.GithubException
        :return:
        &#34;&#34;&#34;
        pass

    @indirect(GithubCommitFlag.get)
    def get_commit_statuses(self, commit: str) -&gt; List[CommitFlag]:
        &#34;&#34;&#34;
        Get status of the commit.

        :param commit: str
        :return: [CommitFlag]
        &#34;&#34;&#34;
        pass

    @indirect(GithubCheckRun.get)
    def get_check_run(
        self,
        check_run_id: Optional[int] = None,
        commit_sha: Optional[str] = None,
    ) -&gt; Optional[&#34;GithubCheckRun&#34;]:
        pass

    @indirect(GithubCheckRun.create)
    def create_check_run(
        self,
        name: str,
        commit_sha: str,
        url: Optional[str] = None,
        external_id: Optional[str] = None,
        status: GithubCheckRunStatus = GithubCheckRunStatus.queued,
        started_at: Optional[datetime.datetime] = None,
        conclusion: Optional[GithubCheckRunResult] = None,
        completed_at: Optional[datetime.datetime] = None,
        output: Optional[GithubCheckRunOutput] = None,
        actions: Optional[List[Dict[str, str]]] = None,
    ) -&gt; &#34;GithubCheckRun&#34;:
        pass

    @indirect(GithubCheckRun.get_list)
    def get_check_runs(
        self,
        commit_sha: str,
        name: Optional[str] = None,
        status: Optional[GithubCheckRunStatus] = None,
    ) -&gt; List[&#34;GithubCheckRun&#34;]:
        pass

    def get_git_urls(self) -&gt; Dict[str, str]:
        return {&#34;git&#34;: self.github_repo.clone_url, &#34;ssh&#34;: self.github_repo.ssh_url}

    @if_readonly(return_function=GitProjectReadOnly.fork_create)
    def fork_create(self) -&gt; &#34;GithubProject&#34;:
        &#34;&#34;&#34;
        Fork this project using the authenticated user.
        This may raise an exception if the fork already exists.

        :return: fork GithubProject instance
        &#34;&#34;&#34;
        gh_user = self.github_instance.get_user()
        fork = self.service.get_project_from_github_repository(
            gh_user.create_fork(self.github_repo)
        )
        logger.debug(f&#34;Forked to {fork.namespace}/{fork.repo}&#34;)
        return fork

    def change_token(self, new_token: str):
        raise OperationNotSupported

    def get_file_content(self, path: str, ref=None) -&gt; str:
        ref = ref or self.default_branch
        try:
            return self.github_repo.get_contents(
                path=path, ref=ref
            ).decoded_content.decode()
        except (UnknownObjectException, GithubException) as ex:
            if ex.status == 404:
                raise FileNotFoundError(f&#34;File &#39;{path}&#39; on {ref} not found&#34;, ex)
            raise GithubAPIException(ex)

    def get_files(
        self, ref: str = None, filter_regex: str = None, recursive: bool = False
    ) -&gt; List[str]:
        &#34;&#34;&#34;
        Get a list of file paths of the repo.
        :param ref: branch or commit (defaults to repo&#39;s default branch)
        :param filter_regex: filter the paths with re.search
        :param recursive: whether to return only top directory files or all files recursively
        :return: [str]
        &#34;&#34;&#34;
        ref = ref or self.default_branch
        paths = []
        contents = self.github_repo.get_contents(path=&#34;&#34;, ref=ref)

        if recursive:
            while contents:
                file_content = contents.pop(0)
                if file_content.type == &#34;dir&#34;:
                    contents.extend(
                        self.github_repo.get_contents(path=file_content.path, ref=ref)
                    )
                else:
                    paths.append(file_content.path)

        else:
            paths = [
                file_content.path
                for file_content in contents
                if file_content.type != &#34;dir&#34;
            ]

        if filter_regex:
            paths = filter_paths(paths, filter_regex)

        return paths

    def _release_from_github_object(
        self, raw_release: PyGithubRelease, git_tag: GitTag
    ) -&gt; GithubRelease:
        &#34;&#34;&#34;
        Get ogr.abstract.Release object from github.GithubRelease

        :param raw_release: GithubRelease, object from Github API
            https://developer.github.com/v3/repos/releases/
        :return: Release, example(type, value):
            tag_name: str, &#34;v1.0.0&#34;
            url: str, &#34;https://api.github.com/repos/octocat/Hello-World/releases/1&#34;
            created_at: datetime.datetime, 2018-09-19 12:56:26
            tarball_url: str, &#34;https://api.github.com/repos/octocat/Hello-World/tarball/v1.0.0&#34;
            git_tag: GitTag
            project: GithubProject
            raw_release: PyGithubRelease
        &#34;&#34;&#34;
        return GithubRelease(
            tag_name=raw_release.tag_name,
            url=raw_release.url,
            created_at=str(raw_release.created_at),
            tarball_url=raw_release.tarball_url,
            git_tag=git_tag,
            project=self,
            raw_release=raw_release,
        )

    @staticmethod
    def _commitcomment_from_github_object(
        raw_commitcoment: GithubCommitComment,
    ) -&gt; CommitComment:
        return CommitComment(
            comment=raw_commitcoment.body,
            author=raw_commitcoment.user.login,
            sha=raw_commitcoment.commit_id,
        )

    def get_labels(self):
        &#34;&#34;&#34;
        Get list of labels in the repository.
        :return: [Label]
        &#34;&#34;&#34;
        return list(self.github_repo.get_labels())

    def update_labels(self, labels):
        &#34;&#34;&#34;
        Update the labels of the repository. (No deletion, only add not existing ones.)

        :param labels: [str]
        :return: int - number of added labels
        &#34;&#34;&#34;
        current_label_names = [la.name for la in list(self.github_repo.get_labels())]
        changes = 0
        for label in labels:
            if label.name not in current_label_names:
                color = self._normalize_label_color(color=label.color)
                self.github_repo.create_label(
                    name=label.name, color=color, description=label.description or &#34;&#34;
                )

                changes += 1
        return changes

    @staticmethod
    def _normalize_label_color(color):
        if color.startswith(&#34;#&#34;):
            return color[1:]
        return color

    def _release_id_from_name(self, name) -&gt; Optional[int]:
        releases = self.github_repo.get_releases()
        for release in releases:
            if release.title == name:
                return release.id
        return None

    def _release_id_from_tag(self, tag) -&gt; Optional[int]:
        releases = self.github_repo.get_releases()
        for release in releases:
            if release.tag_name == tag:
                return release.id
        return None

    def get_release(self, identifier=None, name=None, tag_name=None) -&gt; GithubRelease:
        if tag_name:
            identifier = self._release_id_from_tag(tag_name)
        elif name:
            identifier = self._release_id_from_name(name)
        if identifier is None:
            raise GithubAPIException(&#34;Release was not found.&#34;)
        release = self.github_repo.get_release(id=identifier)
        return self._release_from_github_object(
            raw_release=release, git_tag=self.get_tag_from_tag_name(release.tag_name)
        )

    def get_latest_release(self) -&gt; Optional[GithubRelease]:
        try:
            release = self.github_repo.get_latest_release()
            return self._release_from_github_object(
                raw_release=release,
                git_tag=self.get_tag_from_tag_name(release.tag_name),
            )
        except GithubException as ex:
            if ex.status == 404:
                return None
            raise GithubAPIException from ex

    def get_releases(self) -&gt; List[Release]:
        releases = self.github_repo.get_releases()
        return [
            self._release_from_github_object(
                raw_release=release,
                git_tag=self.get_tag_from_tag_name(release.tag_name),
            )
            for release in releases
        ]

    def create_release(self, tag: str, name: str, message: str) -&gt; GithubRelease:
        created_release = self.github_repo.create_git_release(
            tag=tag, name=name, message=message
        )
        return self.get_release(created_release.id)

    def get_forks(self) -&gt; List[&#34;GithubProject&#34;]:
        &#34;&#34;&#34;
        Get forks of the project.

        :return: [PagureProject]
        &#34;&#34;&#34;
        return [
            self.service.get_project_from_github_repository(fork)
            for fork in self.github_repo.get_forks()
            if fork.owner
        ]

    def get_web_url(self) -&gt; str:
        &#34;&#34;&#34;
        Get web URL of the project.

        :return: str
        &#34;&#34;&#34;
        return self.github_repo.html_url

    def get_tags(self) -&gt; List[&#34;GitTag&#34;]:
        return [GitTag(tag.name, tag.commit.sha) for tag in self.github_repo.get_tags()]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="ogr.services.base.BaseGitProject" href="../base.html#ogr.services.base.BaseGitProject">BaseGitProject</a></li>
<li><a title="ogr.abstract.GitProject" href="../../abstract.html#ogr.abstract.GitProject">GitProject</a></li>
<li><a title="ogr.abstract.OgrAbstractClass" href="../../abstract.html#ogr.abstract.OgrAbstractClass">OgrAbstractClass</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="ogr.services.github.project.GithubProject.CAN_MERGE_PERMS"><code class="name">var <span class="ident">CAN_MERGE_PERMS</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="ogr.services.github.project.GithubProject.service"><code class="name">var <span class="ident">service</span> : <a title="ogr.services.github.service.GithubService" href="service.html#ogr.services.github.service.GithubService">GithubService</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="ogr.services.github.project.GithubProject.github_instance"><code class="name">var <span class="ident">github_instance</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def github_instance(self):
    if not self._github_instance:
        self._github_instance = self.service.get_pygithub_instance(
            self.namespace, self.repo
        )

    return self._github_instance</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.github_repo"><code class="name">var <span class="ident">github_repo</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def github_repo(self):
    if not self._github_repo:
        self._github_repo = self.github_instance.get_repo(
            full_name_or_id=f&#34;{self.namespace}/{self.repo}&#34;
        )
    return self._github_repo</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.is_fork"><code class="name">var <span class="ident">is_fork</span> : bool</code></dt>
<dd>
<div class="desc"><p>Is this repository a fork?</p>
<p>:return: True if it is</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_fork(self) -&gt; bool:
    &#34;&#34;&#34;
    Is this repository a fork?

    :return: True if it is
    &#34;&#34;&#34;
    return self.github_repo.fork</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="ogr.services.github.project.GithubProject.add_user"><code class="name flex">
<span>def <span class="ident">add_user</span></span>(<span>self, user: str, access_level: <a title="ogr.abstract.AccessLevel" href="../../abstract.html#ogr.abstract.AccessLevel">AccessLevel</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>AccessLevel.pull =&gt; Pull
AccessLevel.triage =&gt; Triage
AccessLevel.push =&gt; Push
AccessLevel.admin =&gt; Admin
AccessLevel.maintain =&gt; Maintain</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_user(self, user: str, access_level: AccessLevel) -&gt; None:
    &#34;&#34;&#34;
    AccessLevel.pull =&gt; Pull
    AccessLevel.triage =&gt; Triage
    AccessLevel.push =&gt; Push
    AccessLevel.admin =&gt; Admin
    AccessLevel.maintain =&gt; Maintain
    &#34;&#34;&#34;
    access_dict = {
        AccessLevel.pull: &#34;Pull&#34;,
        AccessLevel.triage: &#34;Triage&#34;,
        AccessLevel.push: &#34;Push&#34;,
        AccessLevel.admin: &#34;Admin&#34;,
        AccessLevel.maintain: &#34;Maintain&#34;,
    }
    try:
        invitation = self.github_repo.add_to_collaborators(
            user, permission=access_dict[access_level]
        )
    except Exception:
        raise GithubAPIException(&#34;User {user} not found&#34;)

    if invitation is None:
        raise GithubAPIException(&#34;User already added&#34;)</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.commit_comment"><code class="name flex">
<span>def <span class="ident">commit_comment</span></span>(<span>self, commit: str, body: str, filename: str = None, row: int = None) ‑> <a title="ogr.abstract.CommitComment" href="../../abstract.html#ogr.abstract.CommitComment">CommitComment</a></span>
</code></dt>
<dd>
<div class="desc"><p>Create comment on a commit.</p>
<p>:param commit: str The SHA of the commit needing a comment.
:param body: str The text of the comment
:param filename: str The relative path to the file that necessitates a comment
:param row: int Line index in the diff to comment on.
:return: CommitComment</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@if_readonly(
    return_function=GitProjectReadOnly.commit_comment,
    log_message=&#34;Create Comment to commit&#34;,
)
def commit_comment(
    self, commit: str, body: str, filename: str = None, row: int = None
) -&gt; CommitComment:
    &#34;&#34;&#34;
    Create comment on a commit.

    :param commit: str The SHA of the commit needing a comment.
    :param body: str The text of the comment
    :param filename: str The relative path to the file that necessitates a comment
    :param row: int Line index in the diff to comment on.
    :return: CommitComment
    &#34;&#34;&#34;
    github_commit = self.github_repo.get_commit(commit)
    if filename and row:
        comment = github_commit.create_comment(
            body=body, position=row, path=filename
        )
    else:
        comment = github_commit.create_comment(body=body)
    return self._commitcomment_from_github_object(comment)</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.create_check_run"><code class="name flex">
<span>def <span class="ident">create_check_run</span></span>(<span>self, name: str, commit_sha: str, url: Optional[str] = None, external_id: Optional[str] = None, status: <a title="ogr.services.github.check_run.GithubCheckRunStatus" href="check_run.html#ogr.services.github.check_run.GithubCheckRunStatus">GithubCheckRunStatus</a> = GithubCheckRunStatus.queued, started_at: Optional[datetime.datetime] = None, conclusion: Optional[<a title="ogr.services.github.check_run.GithubCheckRunResult" href="check_run.html#ogr.services.github.check_run.GithubCheckRunResult">GithubCheckRunResult</a>] = None, completed_at: Optional[datetime.datetime] = None, output: Optional[Dict[str, Union[str, List[Dict[str, Union[str, int]]]]]] = None, actions: Optional[List[Dict[str, str]]] = None) ‑> <a title="ogr.services.github.check_run.GithubCheckRun" href="check_run.html#ogr.services.github.check_run.GithubCheckRun">GithubCheckRun</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@indirect(GithubCheckRun.create)
def create_check_run(
    self,
    name: str,
    commit_sha: str,
    url: Optional[str] = None,
    external_id: Optional[str] = None,
    status: GithubCheckRunStatus = GithubCheckRunStatus.queued,
    started_at: Optional[datetime.datetime] = None,
    conclusion: Optional[GithubCheckRunResult] = None,
    completed_at: Optional[datetime.datetime] = None,
    output: Optional[GithubCheckRunOutput] = None,
    actions: Optional[List[Dict[str, str]]] = None,
) -&gt; &#34;GithubCheckRun&#34;:
    pass</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.create_release"><code class="name flex">
<span>def <span class="ident">create_release</span></span>(<span>self, tag: str, name: str, message: str) ‑> <a title="ogr.services.github.release.GithubRelease" href="release.html#ogr.services.github.release.GithubRelease">GithubRelease</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_release(self, tag: str, name: str, message: str) -&gt; GithubRelease:
    created_release = self.github_repo.create_git_release(
        tag=tag, name=name, message=message
    )
    return self.get_release(created_release.id)</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.fork_create"><code class="name flex">
<span>def <span class="ident">fork_create</span></span>(<span>self) ‑> <a title="ogr.services.github.project.GithubProject" href="#ogr.services.github.project.GithubProject">GithubProject</a></span>
</code></dt>
<dd>
<div class="desc"><p>Fork this project using the authenticated user.
This may raise an exception if the fork already exists.</p>
<p>:return: fork GithubProject instance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@if_readonly(return_function=GitProjectReadOnly.fork_create)
def fork_create(self) -&gt; &#34;GithubProject&#34;:
    &#34;&#34;&#34;
    Fork this project using the authenticated user.
    This may raise an exception if the fork already exists.

    :return: fork GithubProject instance
    &#34;&#34;&#34;
    gh_user = self.github_instance.get_user()
    fork = self.service.get_project_from_github_repository(
        gh_user.create_fork(self.github_repo)
    )
    logger.debug(f&#34;Forked to {fork.namespace}/{fork.repo}&#34;)
    return fork</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_check_run"><code class="name flex">
<span>def <span class="ident">get_check_run</span></span>(<span>self, check_run_id: Optional[int] = None, commit_sha: Optional[str] = None) ‑> Optional[<a title="ogr.services.github.check_run.GithubCheckRun" href="check_run.html#ogr.services.github.check_run.GithubCheckRun">GithubCheckRun</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@indirect(GithubCheckRun.get)
def get_check_run(
    self,
    check_run_id: Optional[int] = None,
    commit_sha: Optional[str] = None,
) -&gt; Optional[&#34;GithubCheckRun&#34;]:
    pass</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_check_runs"><code class="name flex">
<span>def <span class="ident">get_check_runs</span></span>(<span>self, commit_sha: str, name: Optional[str] = None, status: Optional[<a title="ogr.services.github.check_run.GithubCheckRunStatus" href="check_run.html#ogr.services.github.check_run.GithubCheckRunStatus">GithubCheckRunStatus</a>] = None) ‑> List[<a title="ogr.services.github.check_run.GithubCheckRun" href="check_run.html#ogr.services.github.check_run.GithubCheckRun">GithubCheckRun</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@indirect(GithubCheckRun.get_list)
def get_check_runs(
    self,
    commit_sha: str,
    name: Optional[str] = None,
    status: Optional[GithubCheckRunStatus] = None,
) -&gt; List[&#34;GithubCheckRun&#34;]:
    pass</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_fork"><code class="name flex">
<span>def <span class="ident">get_fork</span></span>(<span>self, create: bool = True) ‑> Optional[<a title="ogr.services.github.project.GithubProject" href="#ogr.services.github.project.GithubProject">GithubProject</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Provide GithubProject instance of a fork of this project.</p>
<p>Returns None if this is a fork.</p>
<p>:param create: create a fork if it doesn't exist
:return: instance of GithubProject</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_fork(self, create: bool = True) -&gt; Optional[&#34;GithubProject&#34;]:
    &#34;&#34;&#34;
    Provide GithubProject instance of a fork of this project.

    Returns None if this is a fork.

    :param create: create a fork if it doesn&#39;t exist
    :return: instance of GithubProject
    &#34;&#34;&#34;
    username = self.service.user.get_username()
    for fork in self.get_forks():
        if fork.github_repo.owner.login == username:
            return fork

    if not self.is_forked():
        if create:
            return self.fork_create()
        else:
            logger.info(
                f&#34;Fork of {self.github_repo.full_name}&#34;
                &#34; does not exist and we were asked not to create it.&#34;
            )
            return None
    return self._construct_fork_project()</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_forks"><code class="name flex">
<span>def <span class="ident">get_forks</span></span>(<span>self) ‑> List[<a title="ogr.services.github.project.GithubProject" href="#ogr.services.github.project.GithubProject">GithubProject</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get forks of the project.</p>
<p>:return: [PagureProject]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_forks(self) -&gt; List[&#34;GithubProject&#34;]:
    &#34;&#34;&#34;
    Get forks of the project.

    :return: [PagureProject]
    &#34;&#34;&#34;
    return [
        self.service.get_project_from_github_repository(fork)
        for fork in self.github_repo.get_forks()
        if fork.owner
    ]</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_git_urls"><code class="name flex">
<span>def <span class="ident">get_git_urls</span></span>(<span>self) ‑> Dict[str, str]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_git_urls(self) -&gt; Dict[str, str]:
    return {&#34;git&#34;: self.github_repo.clone_url, &#34;ssh&#34;: self.github_repo.ssh_url}</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_labels"><code class="name flex">
<span>def <span class="ident">get_labels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Get list of labels in the repository.
:return: [Label]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_labels(self):
    &#34;&#34;&#34;
    Get list of labels in the repository.
    :return: [Label]
    &#34;&#34;&#34;
    return list(self.github_repo.get_labels())</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.get_tag_from_tag_name"><code class="name flex">
<span>def <span class="ident">get_tag_from_tag_name</span></span>(<span>self, tag_name: str) ‑> Optional[<a title="ogr.abstract.GitTag" href="../../abstract.html#ogr.abstract.GitTag">GitTag</a>]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_tag_from_tag_name(self, tag_name: str) -&gt; Optional[GitTag]:
    all_tags = self.github_repo.get_tags()
    for tag in all_tags:
        if tag.name == tag_name:
            return GitTag(name=tag.name, commit_sha=tag.commit.sha)
    return None</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.is_private"><code class="name flex">
<span>def <span class="ident">is_private</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Is this repo private? (accessible only by users with granted access)</p>
<p>:return: if yes, return True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_private(self) -&gt; bool:
    &#34;&#34;&#34;
    Is this repo private? (accessible only by users with granted access)

    :return: if yes, return True
    &#34;&#34;&#34;
    return self.github_repo.private</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.set_commit_status"><code class="name flex">
<span>def <span class="ident">set_commit_status</span></span>(<span>self, commit: str, state: Union[<a title="ogr.abstract.CommitStatus" href="../../abstract.html#ogr.abstract.CommitStatus">CommitStatus</a>, str], target_url: str, description: str, context: str, trim: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a status on a commit</p>
<p>:param commit: The SHA of the commit.
:param state: The state of the status.
:param target_url: The target URL to associate with this status.
:param description: A short description of the status
:param context: A label to differentiate this status from the status of other systems.
:param trim: bool Whether to trim the description in order to avoid throwing
github.GithubException
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@if_readonly(
    return_function=GitProjectReadOnly.set_commit_status,
    log_message=&#34;Create a status on a commit&#34;,
)
@indirect(GithubCommitFlag.set)
def set_commit_status(
    self,
    commit: str,
    state: Union[CommitStatus, str],
    target_url: str,
    description: str,
    context: str,
    trim: bool = False,
):
    &#34;&#34;&#34;
    Create a status on a commit

    :param commit: The SHA of the commit.
    :param state: The state of the status.
    :param target_url: The target URL to associate with this status.
    :param description: A short description of the status
    :param context: A label to differentiate this status from the status of other systems.
    :param trim: bool Whether to trim the description in order to avoid throwing
        github.GithubException
    :return:
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="ogr.services.github.project.GithubProject.update_labels"><code class="name flex">
<span>def <span class="ident">update_labels</span></span>(<span>self, labels)</span>
</code></dt>
<dd>
<div class="desc"><p>Update the labels of the repository. (No deletion, only add not existing ones.)</p>
<p>:param labels: [str]
:return: int - number of added labels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_labels(self, labels):
    &#34;&#34;&#34;
    Update the labels of the repository. (No deletion, only add not existing ones.)

    :param labels: [str]
    :return: int - number of added labels
    &#34;&#34;&#34;
    current_label_names = [la.name for la in list(self.github_repo.get_labels())]
    changes = 0
    for label in labels:
        if label.name not in current_label_names:
            color = self._normalize_label_color(color=label.color)
            self.github_repo.create_label(
                name=label.name, color=color, description=label.description or &#34;&#34;
            )

            changes += 1
    return changes</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="ogr.services.base.BaseGitProject" href="../base.html#ogr.services.base.BaseGitProject">BaseGitProject</a></b></code>:
<ul class="hlist">
<li><code><a title="ogr.services.base.BaseGitProject.add_group" href="../../abstract.html#ogr.abstract.GitProject.add_group">add_group</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.can_merge_pr" href="../../abstract.html#ogr.abstract.GitProject.can_merge_pr">can_merge_pr</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.change_token" href="../../abstract.html#ogr.abstract.GitProject.change_token">change_token</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.create_issue" href="../../abstract.html#ogr.abstract.GitProject.create_issue">create_issue</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.create_pr" href="../../abstract.html#ogr.abstract.GitProject.create_pr">create_pr</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.default_branch" href="../../abstract.html#ogr.abstract.GitProject.default_branch">default_branch</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.delete" href="../../abstract.html#ogr.abstract.GitProject.delete">delete</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.description" href="../../abstract.html#ogr.abstract.GitProject.description">description</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.exists" href="../../abstract.html#ogr.abstract.GitProject.exists">exists</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.full_repo_name" href="../../abstract.html#ogr.abstract.GitProject.full_repo_name">full_repo_name</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_branches" href="../../abstract.html#ogr.abstract.GitProject.get_branches">get_branches</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_commit_statuses" href="../../abstract.html#ogr.abstract.GitProject.get_commit_statuses">get_commit_statuses</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_description" href="../../abstract.html#ogr.abstract.GitProject.get_description">get_description</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_file_content" href="../../abstract.html#ogr.abstract.GitProject.get_file_content">get_file_content</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_files" href="../../abstract.html#ogr.abstract.GitProject.get_files">get_files</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_issue" href="../../abstract.html#ogr.abstract.GitProject.get_issue">get_issue</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_issue_list" href="../../abstract.html#ogr.abstract.GitProject.get_issue_list">get_issue_list</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_latest_release" href="../../abstract.html#ogr.abstract.GitProject.get_latest_release">get_latest_release</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_owners" href="../../abstract.html#ogr.abstract.GitProject.get_owners">get_owners</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_pr" href="../../abstract.html#ogr.abstract.GitProject.get_pr">get_pr</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_pr_comments" href="../../abstract.html#ogr.abstract.GitProject.get_pr_comments">get_pr_comments</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_pr_list" href="../../abstract.html#ogr.abstract.GitProject.get_pr_list">get_pr_list</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_release" href="../../abstract.html#ogr.abstract.GitProject.get_release">get_release</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_releases" href="../../abstract.html#ogr.abstract.GitProject.get_releases">get_releases</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_sha_from_tag" href="../../abstract.html#ogr.abstract.GitProject.get_sha_from_tag">get_sha_from_tag</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_tags" href="../../abstract.html#ogr.abstract.GitProject.get_tags">get_tags</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.get_web_url" href="../../abstract.html#ogr.abstract.GitProject.get_web_url">get_web_url</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.is_forked" href="../../abstract.html#ogr.abstract.GitProject.is_forked">is_forked</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.parent" href="../../abstract.html#ogr.abstract.GitProject.parent">parent</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.request_access" href="../../abstract.html#ogr.abstract.GitProject.request_access">request_access</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.search_in_pr" href="../../abstract.html#ogr.abstract.GitProject.search_in_pr">search_in_pr</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.who_can_close_issue" href="../../abstract.html#ogr.abstract.GitProject.who_can_close_issue">who_can_close_issue</a></code></li>
<li><code><a title="ogr.services.base.BaseGitProject.who_can_merge_pr" href="../../abstract.html#ogr.abstract.GitProject.who_can_merge_pr">who_can_merge_pr</a></code></li>
</ul>
</li>
<li><code><b><a title="ogr.abstract.GitProject" href="../../abstract.html#ogr.abstract.GitProject">GitProject</a></b></code>:
<ul class="hlist">
<li><code><a title="ogr.abstract.GitProject.add_issue_labels" href="../../abstract.html#ogr.abstract.GitProject.add_issue_labels">add_issue_labels</a></code></li>
<li><code><a title="ogr.abstract.GitProject.add_pr_labels" href="../../abstract.html#ogr.abstract.GitProject.add_pr_labels">add_pr_labels</a></code></li>
<li><code><a title="ogr.abstract.GitProject.can_close_issue" href="../../abstract.html#ogr.abstract.GitProject.can_close_issue">can_close_issue</a></code></li>
<li><code><a title="ogr.abstract.GitProject.get_all_pr_commits" href="../../abstract.html#ogr.abstract.GitProject.get_all_pr_commits">get_all_pr_commits</a></code></li>
<li><code><a title="ogr.abstract.GitProject.get_issue_comments" href="../../abstract.html#ogr.abstract.GitProject.get_issue_comments">get_issue_comments</a></code></li>
<li><code><a title="ogr.abstract.GitProject.get_issue_info" href="../../abstract.html#ogr.abstract.GitProject.get_issue_info">get_issue_info</a></code></li>
<li><code><a title="ogr.abstract.GitProject.get_issue_labels" href="../../abstract.html#ogr.abstract.GitProject.get_issue_labels">get_issue_labels</a></code></li>
<li><code><a title="ogr.abstract.GitProject.get_pr_info" href="../../abstract.html#ogr.abstract.GitProject.get_pr_info">get_pr_info</a></code></li>
<li><code><a title="ogr.abstract.GitProject.get_pr_labels" href="../../abstract.html#ogr.abstract.GitProject.get_pr_labels">get_pr_labels</a></code></li>
<li><code><a title="ogr.abstract.GitProject.issue_close" href="../../abstract.html#ogr.abstract.GitProject.issue_close">issue_close</a></code></li>
<li><code><a title="ogr.abstract.GitProject.issue_comment" href="../../abstract.html#ogr.abstract.GitProject.issue_comment">issue_comment</a></code></li>
<li><code><a title="ogr.abstract.GitProject.pr_close" href="../../abstract.html#ogr.abstract.GitProject.pr_close">pr_close</a></code></li>
<li><code><a title="ogr.abstract.GitProject.pr_comment" href="../../abstract.html#ogr.abstract.GitProject.pr_comment">pr_comment</a></code></li>
<li><code><a title="ogr.abstract.GitProject.pr_create" href="../../abstract.html#ogr.abstract.GitProject.pr_create">pr_create</a></code></li>
<li><code><a title="ogr.abstract.GitProject.pr_merge" href="../../abstract.html#ogr.abstract.GitProject.pr_merge">pr_merge</a></code></li>
<li><code><a title="ogr.abstract.GitProject.update_pr_info" href="../../abstract.html#ogr.abstract.GitProject.update_pr_info">update_pr_info</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ogr.services.github" href="index.html">ogr.services.github</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ogr.services.github.project.GithubProject" href="#ogr.services.github.project.GithubProject">GithubProject</a></code></h4>
<ul class="">
<li><code><a title="ogr.services.github.project.GithubProject.CAN_MERGE_PERMS" href="#ogr.services.github.project.GithubProject.CAN_MERGE_PERMS">CAN_MERGE_PERMS</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.add_user" href="#ogr.services.github.project.GithubProject.add_user">add_user</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.commit_comment" href="#ogr.services.github.project.GithubProject.commit_comment">commit_comment</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.create_check_run" href="#ogr.services.github.project.GithubProject.create_check_run">create_check_run</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.create_release" href="#ogr.services.github.project.GithubProject.create_release">create_release</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.fork_create" href="#ogr.services.github.project.GithubProject.fork_create">fork_create</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_check_run" href="#ogr.services.github.project.GithubProject.get_check_run">get_check_run</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_check_runs" href="#ogr.services.github.project.GithubProject.get_check_runs">get_check_runs</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_fork" href="#ogr.services.github.project.GithubProject.get_fork">get_fork</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_forks" href="#ogr.services.github.project.GithubProject.get_forks">get_forks</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_git_urls" href="#ogr.services.github.project.GithubProject.get_git_urls">get_git_urls</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_labels" href="#ogr.services.github.project.GithubProject.get_labels">get_labels</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.get_tag_from_tag_name" href="#ogr.services.github.project.GithubProject.get_tag_from_tag_name">get_tag_from_tag_name</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.github_instance" href="#ogr.services.github.project.GithubProject.github_instance">github_instance</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.github_repo" href="#ogr.services.github.project.GithubProject.github_repo">github_repo</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.is_fork" href="#ogr.services.github.project.GithubProject.is_fork">is_fork</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.is_private" href="#ogr.services.github.project.GithubProject.is_private">is_private</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.service" href="#ogr.services.github.project.GithubProject.service">service</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.set_commit_status" href="#ogr.services.github.project.GithubProject.set_commit_status">set_commit_status</a></code></li>
<li><code><a title="ogr.services.github.project.GithubProject.update_labels" href="#ogr.services.github.project.GithubProject.update_labels">update_labels</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>